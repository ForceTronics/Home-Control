C51 COMPILER V8.02   MAIN                                                                  01/19/2013 23:14:35 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          * 红外接收数据，中断方式，并通过串口发送
   3          *
   4          * 晶振：11.0592M
   5          */
   6          
   7          #include <reg52.h>
   8          #include <MYCHIP.h>
   9          
  10          typedef unsigned char uint8;
  11          
  12          sbit Ir_Pin = P3^3;
  13          
  14          uint8 Ir_Buf[4]={0x00,0xFF,0x16,0xE6}; //用于保存解码结果
  15          unsigned char DeviceNum;
  16          unsigned char code number[]={0xc0,0xf9,0xa4,0xb0,
  17                                                       0x99,0x92,0x82,0xf8,
  18                                                       0x80,0x90};
  19          unsigned char Receving;
  20          
  21          
  22          /*
  23           * 外部中断初始化
  24          */
  25          void int1_init(void)
  26          {
  27   1              IT1 = 1; //下降沿有效
  28   1              EX1 = 1;
  29   1              EA = 1;
  30   1      }
  31          
  32          void Timer_init()
  33          {
  34   1              TMOD=0x21;
  35   1              TH1 = 0xFD;
  36   1          TL1 = 0xFD;
  37   1      
  38   1          TR1 = 1;
  39   1      }
  40          
  41          
  42          /*
  43           * UART初始化
  44           * 波特率：9600
  45          */
  46          void uart_init(void)
  47          { 
  48   1          SCON = 0x50; 
  49   1      }
  50          
  51          /*
  52           * UART发送一字节
  53          */
  54          void UART_Send_Byte(uint8 dat)
  55          {
C51 COMPILER V8.02   MAIN                                                                  01/19/2013 23:14:35 PAGE 2   

  56   1              SBUF = dat;
  57   1              while (TI == 0);
  58   1              TI = 0;
  59   1      }
  60          
  61          /*
  62           * 数码管初始化
  63          */
  64          void LED_init()
  65          {
  66   1              ENLED1=0;
  67   1              ADDR3=1;
  68   1              ADDR0=0;
  69   1              ADDR1=1;
  70   1              ADDR2=1;
  71   1      }
  72          
  73          
  74          /*
  75           * 获取低电平时间
  76          */
  77          unsigned int Ir_Get_Low()
  78          {
  79   1              TL0 = 0;
  80   1              TH0 = 0;
  81   1              TR0 = 1;
  82   1              while (!Ir_Pin && (TH0&0x80)==0);  
  83   1                    
  84   1              TR0 = 0;           
  85   1              return (TH0 * 256 + TL0);
  86   1      }
  87          
  88          /*
  89           * 获取高电平时间
  90          */
  91          unsigned int Ir_Get_High()
  92          {
  93   1              TL0 = 0;
  94   1              TH0 = 0;
  95   1              TR0 = 1;
  96   1              while (Ir_Pin && (TH0&0x80)==0);
  97   1      
  98   1              TR0 = 0;
  99   1              return (TH0 * 256 + TL0);
 100   1      }
 101          
 102          
 103          main()
 104          {
 105   1              LED_init();
 106   1              Timer_init();
 107   1              uart_init();
 108   1              int1_init();
 109   1      
 110   1              while (1)
 111   1              {
 112   2                      if(RI==1)
 113   2                      {
 114   3                              Receving=SBUF;
 115   3                              switch(Receving>>1)
 116   3                              {
 117   4                                      case 1:DB7=Receving & 0x01;
C51 COMPILER V8.02   MAIN                                                                  01/19/2013 23:14:35 PAGE 3   

 118   4                                      case 2:DB6=Receving & 0x01;
 119   4                                      case 3:DB5=Receving & 0x01;
 120   4                              }       
 121   3                      }
 122   2              }
 123   1      }
 124          
 125          void int1_isr() interrupt 2
 126          {
 127   1              unsigned int temp;
 128   1              char i,j;
 129   1      
 130   1              temp = Ir_Get_Low();
 131   1              if ((temp < 7833) || (temp > 8755))  //引导脉冲低电平8500~9500us
 132   1                      return;
 133   1              temp = Ir_Get_High();
 134   1              if ((temp < 3686) || (temp > 4608))  //引导脉冲高电平4000~5000us
 135   1                      return;
 136   1      
 137   1              for (i=0; i<4; i++) //4个字节
 138   1              {
 139   2                      for (j=0; j<8; j++) //每个字节8位
 140   2                      {
 141   3                              temp = Ir_Get_Low();
 142   3                              if ((temp < 184) || (temp > 737)) //200~800us
 143   3                                      return;
 144   3      
 145   3                              temp = Ir_Get_High();
 146   3                              if ((temp < 184) || (temp > 1843)) //200~2000us
 147   3                                      return;
 148   3      
 149   3                              Ir_Buf[i] >>= 1;
 150   3                              if (temp > 1032) //1120us
 151   3                                      Ir_Buf[i] |= 0x80;
 152   3                      }
 153   2              }
 154   1              //UART_Send_Byte(Ir_Buf[2]);
 155   1              switch(Ir_Buf[2])
 156   1                      {
 157   2                              case 0x0C:DB7=~DB7;DeviceNum=(1<<1)|DB7;UART_Send_Byte(DeviceNum); break;
 158   2                              case 0x18:DB6=~DB6;DeviceNum=(2<<1)|DB6;UART_Send_Byte(DeviceNum); break;
 159   2                              case 0x5E:DB5=~DB5;DeviceNum=(3<<1)|DB5;UART_Send_Byte(DeviceNum); break;
 160   2                      }
 161   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    395    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
